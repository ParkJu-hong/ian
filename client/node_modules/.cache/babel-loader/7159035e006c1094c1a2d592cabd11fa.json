{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst OctetStreamParser = require('../parsers/OctetStream'); // the `options` is also available through the `options` / `formidable.options`\n\n\nmodule.exports = function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/octet-stream/i.test(self.headers['content-type'])) {\n    init.call(self, self, options);\n  }\n\n  return self;\n}; // Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\n\n\nfunction init(_self, _opts) {\n  this.type = 'octet-stream';\n  const originalFilename = this.headers['x-file-name'];\n  const mimetype = this.headers['content-type'];\n  const thisPart = {\n    originalFilename,\n    mimetype\n  };\n\n  const newFilename = this._getNewName(thisPart);\n\n  const filepath = this._joinDirectoryName(newFilename);\n\n  const file = this._newFile({\n    newFilename,\n    filepath,\n    originalFilename,\n    mimetype\n  });\n\n  this.emit('fileBegin', originalFilename, file);\n  file.open();\n  this.openedFiles.push(file);\n  this._flushing += 1;\n  this._parser = new OctetStreamParser(this.options); // Keep track of writes that haven't finished so we don't emit the file before it's done being written\n\n  let outstandingWrites = 0;\n\n  this._parser.on('data', buffer => {\n    this.pause();\n    outstandingWrites += 1;\n    file.write(buffer, () => {\n      outstandingWrites -= 1;\n      this.resume();\n\n      if (this.ended) {\n        this._parser.emit('doneWritingFile');\n      }\n    });\n  });\n\n  this._parser.on('end', () => {\n    this._flushing -= 1;\n    this.ended = true;\n\n    const done = () => {\n      file.end(() => {\n        this.emit('file', 'file', file);\n\n        this._maybeEnd();\n      });\n    };\n\n    if (outstandingWrites === 0) {\n      done();\n    } else {\n      this._parser.once('doneWritingFile', done);\n    }\n  });\n\n  return this;\n}","map":{"version":3,"sources":["/Users/bagjuhong/Desktop/ian/node_modules/formidable/src/plugins/octetstream.js"],"names":["OctetStreamParser","require","module","exports","plugin","formidable","options","self","test","headers","init","call","_self","_opts","type","originalFilename","mimetype","thisPart","newFilename","_getNewName","filepath","_joinDirectoryName","file","_newFile","emit","open","openedFiles","push","_flushing","_parser","outstandingWrites","on","buffer","pause","write","resume","ended","done","end","_maybeEnd","once"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,iBAAiB,GAAGC,OAAO,CAAC,wBAAD,CAAjC,C,CAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,MAAT,CAAgBC,UAAhB,EAA4BC,OAA5B,EAAqC;AACpD;AACA;;AAEA;AACA,QAAMC,IAAI,GAAG,QAAQF,UAArB;;AAEA,MAAI,gBAAgBG,IAAhB,CAAqBD,IAAI,CAACE,OAAL,CAAa,cAAb,CAArB,CAAJ,EAAwD;AACtDC,IAAAA,IAAI,CAACC,IAAL,CAAUJ,IAAV,EAAgBA,IAAhB,EAAsBD,OAAtB;AACD;;AAED,SAAOC,IAAP;AACD,CAZD,C,CAcA;AACA;AACA;;;AACA,SAASG,IAAT,CAAcE,KAAd,EAAqBC,KAArB,EAA4B;AAC1B,OAAKC,IAAL,GAAY,cAAZ;AACA,QAAMC,gBAAgB,GAAG,KAAKN,OAAL,CAAa,aAAb,CAAzB;AACA,QAAMO,QAAQ,GAAG,KAAKP,OAAL,CAAa,cAAb,CAAjB;AAEA,QAAMQ,QAAQ,GAAG;AACfF,IAAAA,gBADe;AAEfC,IAAAA;AAFe,GAAjB;;AAIA,QAAME,WAAW,GAAG,KAAKC,WAAL,CAAiBF,QAAjB,CAApB;;AACA,QAAMG,QAAQ,GAAG,KAAKC,kBAAL,CAAwBH,WAAxB,CAAjB;;AACA,QAAMI,IAAI,GAAG,KAAKC,QAAL,CAAc;AACzBL,IAAAA,WADyB;AAEzBE,IAAAA,QAFyB;AAGzBL,IAAAA,gBAHyB;AAIzBC,IAAAA;AAJyB,GAAd,CAAb;;AAOA,OAAKQ,IAAL,CAAU,WAAV,EAAuBT,gBAAvB,EAAyCO,IAAzC;AACAA,EAAAA,IAAI,CAACG,IAAL;AACA,OAAKC,WAAL,CAAiBC,IAAjB,CAAsBL,IAAtB;AACA,OAAKM,SAAL,IAAkB,CAAlB;AAEA,OAAKC,OAAL,GAAe,IAAI7B,iBAAJ,CAAsB,KAAKM,OAA3B,CAAf,CAvB0B,CAyB1B;;AACA,MAAIwB,iBAAiB,GAAG,CAAxB;;AAEA,OAAKD,OAAL,CAAaE,EAAb,CAAgB,MAAhB,EAAyBC,MAAD,IAAY;AAClC,SAAKC,KAAL;AACAH,IAAAA,iBAAiB,IAAI,CAArB;AAEAR,IAAAA,IAAI,CAACY,KAAL,CAAWF,MAAX,EAAmB,MAAM;AACvBF,MAAAA,iBAAiB,IAAI,CAArB;AACA,WAAKK,MAAL;;AAEA,UAAI,KAAKC,KAAT,EAAgB;AACd,aAAKP,OAAL,CAAaL,IAAb,CAAkB,iBAAlB;AACD;AACF,KAPD;AAQD,GAZD;;AAcA,OAAKK,OAAL,CAAaE,EAAb,CAAgB,KAAhB,EAAuB,MAAM;AAC3B,SAAKH,SAAL,IAAkB,CAAlB;AACA,SAAKQ,KAAL,GAAa,IAAb;;AAEA,UAAMC,IAAI,GAAG,MAAM;AACjBf,MAAAA,IAAI,CAACgB,GAAL,CAAS,MAAM;AACb,aAAKd,IAAL,CAAU,MAAV,EAAkB,MAAlB,EAA0BF,IAA1B;;AACA,aAAKiB,SAAL;AACD,OAHD;AAID,KALD;;AAOA,QAAIT,iBAAiB,KAAK,CAA1B,EAA6B;AAC3BO,MAAAA,IAAI;AACL,KAFD,MAEO;AACL,WAAKR,OAAL,CAAaW,IAAb,CAAkB,iBAAlB,EAAqCH,IAArC;AACD;AACF,GAhBD;;AAkBA,SAAO,IAAP;AACD","sourcesContent":["/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst OctetStreamParser = require('../parsers/OctetStream');\n\n// the `options` is also available through the `options` / `formidable.options`\nmodule.exports = function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/octet-stream/i.test(self.headers['content-type'])) {\n    init.call(self, self, options);\n  }\n\n  return self;\n};\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction init(_self, _opts) {\n  this.type = 'octet-stream';\n  const originalFilename = this.headers['x-file-name'];\n  const mimetype = this.headers['content-type'];\n\n  const thisPart = {\n    originalFilename,\n    mimetype,\n  };\n  const newFilename = this._getNewName(thisPart);\n  const filepath = this._joinDirectoryName(newFilename);\n  const file = this._newFile({\n    newFilename,\n    filepath,\n    originalFilename,\n    mimetype,\n  });\n\n  this.emit('fileBegin', originalFilename, file);\n  file.open();\n  this.openedFiles.push(file);\n  this._flushing += 1;\n\n  this._parser = new OctetStreamParser(this.options);\n\n  // Keep track of writes that haven't finished so we don't emit the file before it's done being written\n  let outstandingWrites = 0;\n\n  this._parser.on('data', (buffer) => {\n    this.pause();\n    outstandingWrites += 1;\n\n    file.write(buffer, () => {\n      outstandingWrites -= 1;\n      this.resume();\n\n      if (this.ended) {\n        this._parser.emit('doneWritingFile');\n      }\n    });\n  });\n\n  this._parser.on('end', () => {\n    this._flushing -= 1;\n    this.ended = true;\n\n    const done = () => {\n      file.end(() => {\n        this.emit('file', 'file', file);\n        this._maybeEnd();\n      });\n    };\n\n    if (outstandingWrites === 0) {\n      done();\n    } else {\n      this._parser.once('doneWritingFile', done);\n    }\n  });\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"script"}