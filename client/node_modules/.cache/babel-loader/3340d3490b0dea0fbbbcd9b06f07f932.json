{"ast":null,"code":"/* eslint-disable no-fallthrough */\n\n/* eslint-disable no-bitwise */\n\n/* eslint-disable no-plusplus */\n\n/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst {\n  Transform\n} = require('stream');\n\nconst errors = require('../FormidableError.js');\n\nconst {\n  FormidableError\n} = errors;\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++\n};\nlet f = 1;\nconst FBOUNDARY = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nfunction lower(c) {\n  return c | 0x20;\n}\n\nexports.STATES = {};\nObject.keys(STATE).forEach(stateName => {\n  exports.STATES[stateName] = STATE[stateName];\n});\n\nclass MultipartParser extends Transform {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      readableObjectMode: true\n    });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n    this.globalOptions = { ...options\n    };\n    this.index = null;\n    this.flags = 0;\n  }\n\n  _flush(done) {\n    if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {\n      this._handleCallback('partEnd');\n\n      this._handleCallback('end');\n\n      done();\n    } else if (this.state !== STATE.END) {\n      done(new FormidableError(`MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`, errors.malformedMultipart, 400));\n    }\n  }\n\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  } // eslint-disable-next-line max-params\n\n\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n\n    this.push({\n      name,\n      buffer: buf,\n      start,\n      end\n    });\n  } // eslint-disable-next-line max-statements\n\n\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let {\n      index,\n      state,\n      flags\n    } = this;\n    const {\n      lookbehind,\n      boundary,\n      boundaryChars\n    } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n\n    const clearMarkSymbol = name => {\n      delete this[`${name}Mark`];\n    };\n\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n\n        clearMarkSymbol(name);\n      }\n    };\n\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          return i;\n\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return i;\n            }\n\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n\n              this._handleCallback('partBegin');\n\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              return i;\n            }\n\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n\n          break;\n\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return i;\n            }\n\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n\n          if (cl < A || cl > Z) {\n            return i;\n          }\n\n          break;\n\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n\n            this._handleCallback('headerEnd');\n\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n\n          break;\n\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n\n          state = STATE.HEADER_FIELD_START;\n          break;\n\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n\n          this._handleCallback('headersEnd');\n\n          state = STATE.PART_DATA_START;\n          break;\n\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n\n        case STATE.PART_DATA:\n          prevIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n\n                this._handleCallback('partEnd');\n\n                this._handleCallback('partBegin');\n\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n\n                this._handleCallback('end');\n\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n\n            prevIndex = 0;\n            setMark('partData'); // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n\n            i--;\n          }\n\n          break;\n\n        case STATE.END:\n          break;\n\n        default:\n          return i;\n      }\n    }\n\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n    done();\n    return this.bufferLength;\n  }\n\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n\n} // eslint-disable-next-line consistent-return\n\n\nMultipartParser.stateToString = stateNumber => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\n\nmodule.exports = Object.assign(MultipartParser, {\n  STATES: exports.STATES\n});","map":{"version":3,"sources":["/Users/bagjuhong/Desktop/ian/node_modules/formidable/src/parsers/Multipart.js"],"names":["Transform","require","errors","FormidableError","s","STATE","PARSER_UNINITIALIZED","START","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","PART_END","END","f","FBOUNDARY","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","exports","STATES","Object","keys","forEach","stateName","MultipartParser","constructor","options","readableObjectMode","boundary","boundaryChars","lookbehind","bufferLength","state","globalOptions","index","flags","_flush","done","length","_handleCallback","explain","malformedMultipart","initWithBoundary","str","Buffer","from","alloc","i","name","buf","start","end","undefined","push","buffer","_transform","_","prevIndex","boundaryLength","boundaryEnd","cl","setMark","idx","clearMarkSymbol","dataCallback","shouldClear","markSymbol","stateToString","stateNumber","number","module","assign"],"mappings":"AAAA;;AACA;;AACA;;AACA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,uBAAD,CAAtB;;AAEA,MAAM;AAAEE,EAAAA;AAAF,IAAsBD,MAA5B;AAEA,IAAIE,CAAC,GAAG,CAAR;AACA,MAAMC,KAAK,GAAG;AACZC,EAAAA,oBAAoB,EAAEF,CAAC,EADX;AAEZG,EAAAA,KAAK,EAAEH,CAAC,EAFI;AAGZI,EAAAA,cAAc,EAAEJ,CAAC,EAHL;AAIZK,EAAAA,kBAAkB,EAAEL,CAAC,EAJT;AAKZM,EAAAA,YAAY,EAAEN,CAAC,EALH;AAMZO,EAAAA,kBAAkB,EAAEP,CAAC,EANT;AAOZQ,EAAAA,YAAY,EAAER,CAAC,EAPH;AAQZS,EAAAA,wBAAwB,EAAET,CAAC,EARf;AASZU,EAAAA,mBAAmB,EAAEV,CAAC,EATV;AAUZW,EAAAA,eAAe,EAAEX,CAAC,EAVN;AAWZY,EAAAA,SAAS,EAAEZ,CAAC,EAXA;AAYZa,EAAAA,QAAQ,EAAEb,CAAC,EAZC;AAaZc,EAAAA,GAAG,EAAEd,CAAC;AAbM,CAAd;AAgBA,IAAIe,CAAC,GAAG,CAAR;AACA,MAAMC,SAAS,GAAG;AAAEC,EAAAA,aAAa,EAAEF,CAAjB;AAAoBG,EAAAA,aAAa,EAAGH,CAAC,IAAI;AAAzC,CAAlB;AAEA,MAAMI,EAAE,GAAG,EAAX;AACA,MAAMC,EAAE,GAAG,EAAX;AACA,MAAMC,KAAK,GAAG,EAAd;AACA,MAAMC,MAAM,GAAG,EAAf;AACA,MAAMC,KAAK,GAAG,EAAd;AACA,MAAMC,CAAC,GAAG,EAAV;AACA,MAAMC,CAAC,GAAG,GAAV;;AAEA,SAASC,KAAT,CAAeC,CAAf,EAAkB;AAChB,SAAOA,CAAC,GAAG,IAAX;AACD;;AAEDC,OAAO,CAACC,MAAR,GAAiB,EAAjB;AAEAC,MAAM,CAACC,IAAP,CAAY9B,KAAZ,EAAmB+B,OAAnB,CAA4BC,SAAD,IAAe;AACxCL,EAAAA,OAAO,CAACC,MAAR,CAAeI,SAAf,IAA4BhC,KAAK,CAACgC,SAAD,CAAjC;AACD,CAFD;;AAIA,MAAMC,eAAN,SAA8BtC,SAA9B,CAAwC;AACtCuC,EAAAA,WAAW,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACxB,UAAM;AAAEC,MAAAA,kBAAkB,EAAE;AAAtB,KAAN;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,aAAL,GAAqB,IAArB;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKC,KAAL,GAAazC,KAAK,CAACC,oBAAnB;AAEA,SAAKyC,aAAL,GAAqB,EAAE,GAAGP;AAAL,KAArB;AACA,SAAKQ,KAAL,GAAa,IAAb;AACA,SAAKC,KAAL,GAAa,CAAb;AACD;;AAEDC,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX,QACG,KAAKL,KAAL,KAAezC,KAAK,CAACI,kBAArB,IAA2C,KAAKuC,KAAL,KAAe,CAA3D,IACC,KAAKF,KAAL,KAAezC,KAAK,CAACW,SAArB,IAAkC,KAAKgC,KAAL,KAAe,KAAKN,QAAL,CAAcU,MAFlE,EAGE;AACA,WAAKC,eAAL,CAAqB,SAArB;;AACA,WAAKA,eAAL,CAAqB,KAArB;;AACAF,MAAAA,IAAI;AACL,KAPD,MAOO,IAAI,KAAKL,KAAL,KAAezC,KAAK,CAACa,GAAzB,EAA8B;AACnCiC,MAAAA,IAAI,CACF,IAAIhD,eAAJ,CACG,qDAAoD,KAAKmD,OAAL,EAAe,EADtE,EAEEpD,MAAM,CAACqD,kBAFT,EAGE,GAHF,CADE,CAAJ;AAOD;AACF;;AAEDC,EAAAA,gBAAgB,CAACC,GAAD,EAAM;AACpB,SAAKf,QAAL,GAAgBgB,MAAM,CAACC,IAAP,CAAa,SAAQF,GAAI,EAAzB,CAAhB;AACA,SAAKb,UAAL,GAAkBc,MAAM,CAACE,KAAP,CAAa,KAAKlB,QAAL,CAAcU,MAAd,GAAuB,CAApC,CAAlB;AACA,SAAKN,KAAL,GAAazC,KAAK,CAACE,KAAnB;AACA,SAAKoC,aAAL,GAAqB,EAArB;;AAEA,SAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKnB,QAAL,CAAcU,MAAlC,EAA0CS,CAAC,EAA3C,EAA+C;AAC7C,WAAKlB,aAAL,CAAmB,KAAKD,QAAL,CAAcmB,CAAd,CAAnB,IAAuC,IAAvC;AACD;AACF,GA1CqC,CA4CtC;;;AACAR,EAAAA,eAAe,CAACS,IAAD,EAAOC,GAAP,EAAYC,KAAZ,EAAmBC,GAAnB,EAAwB;AACrC,QAAID,KAAK,KAAKE,SAAV,IAAuBF,KAAK,KAAKC,GAArC,EAA0C;AACxC;AACD;;AACD,SAAKE,IAAL,CAAU;AAAEL,MAAAA,IAAF;AAAQM,MAAAA,MAAM,EAAEL,GAAhB;AAAqBC,MAAAA,KAArB;AAA4BC,MAAAA;AAA5B,KAAV;AACD,GAlDqC,CAoDtC;;;AACAI,EAAAA,UAAU,CAACD,MAAD,EAASE,CAAT,EAAYnB,IAAZ,EAAkB;AAC1B,QAAIU,CAAC,GAAG,CAAR;AACA,QAAIU,SAAS,GAAG,KAAKvB,KAArB;AACA,QAAI;AAAEA,MAAAA,KAAF;AAASF,MAAAA,KAAT;AAAgBG,MAAAA;AAAhB,QAA0B,IAA9B;AACA,UAAM;AAAEL,MAAAA,UAAF;AAAcF,MAAAA,QAAd;AAAwBC,MAAAA;AAAxB,QAA0C,IAAhD;AACA,UAAM6B,cAAc,GAAG9B,QAAQ,CAACU,MAAhC;AACA,UAAMqB,WAAW,GAAGD,cAAc,GAAG,CAArC;AACA,SAAK3B,YAAL,GAAoBuB,MAAM,CAAChB,MAA3B;AACA,QAAIrB,CAAC,GAAG,IAAR;AACA,QAAI2C,EAAE,GAAG,IAAT;;AAEA,UAAMC,OAAO,GAAG,CAACb,IAAD,EAAOc,GAAP,KAAe;AAC7B,WAAM,GAAEd,IAAK,MAAb,IAAsB,OAAOc,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCf,CAAtD;AACD,KAFD;;AAIA,UAAMgB,eAAe,GAAIf,IAAD,IAAU;AAChC,aAAO,KAAM,GAAEA,IAAK,MAAb,CAAP;AACD,KAFD;;AAIA,UAAMgB,YAAY,GAAG,CAAChB,IAAD,EAAOiB,WAAP,KAAuB;AAC1C,YAAMC,UAAU,GAAI,GAAElB,IAAK,MAA3B;;AACA,UAAI,EAAEkB,UAAU,IAAI,IAAhB,CAAJ,EAA2B;AACzB;AACD;;AAED,UAAI,CAACD,WAAL,EAAkB;AAChB,aAAK1B,eAAL,CAAqBS,IAArB,EAA2BM,MAA3B,EAAmC,KAAKY,UAAL,CAAnC,EAAqDZ,MAAM,CAAChB,MAA5D;;AACAuB,QAAAA,OAAO,CAACb,IAAD,EAAO,CAAP,CAAP;AACD,OAHD,MAGO;AACL,aAAKT,eAAL,CAAqBS,IAArB,EAA2BM,MAA3B,EAAmC,KAAKY,UAAL,CAAnC,EAAqDnB,CAArD;;AACAgB,QAAAA,eAAe,CAACf,IAAD,CAAf;AACD;AACF,KAbD;;AAeA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKhB,YAArB,EAAmCgB,CAAC,EAApC,EAAwC;AACtC9B,MAAAA,CAAC,GAAGqC,MAAM,CAACP,CAAD,CAAV;;AACA,cAAQf,KAAR;AACE,aAAKzC,KAAK,CAACC,oBAAX;AACE,iBAAOuD,CAAP;;AACF,aAAKxD,KAAK,CAACE,KAAX;AACEyC,UAAAA,KAAK,GAAG,CAAR;AACAF,UAAAA,KAAK,GAAGzC,KAAK,CAACG,cAAd;;AACF,aAAKH,KAAK,CAACG,cAAX;AACE,cAAIwC,KAAK,KAAKN,QAAQ,CAACU,MAAT,GAAkB,CAAhC,EAAmC;AACjC,gBAAIrB,CAAC,KAAKL,MAAV,EAAkB;AAChBuB,cAAAA,KAAK,IAAI7B,SAAS,CAACE,aAAnB;AACD,aAFD,MAEO,IAAIS,CAAC,KAAKP,EAAV,EAAc;AACnB,qBAAOqC,CAAP;AACD;;AACDb,YAAAA,KAAK;AACL;AACD,WARD,MAQO,IAAIA,KAAK,GAAG,CAAR,KAAcN,QAAQ,CAACU,MAAT,GAAkB,CAApC,EAAuC;AAC5C,gBAAIH,KAAK,GAAG7B,SAAS,CAACE,aAAlB,IAAmCS,CAAC,KAAKL,MAA7C,EAAqD;AACnD,mBAAK2B,eAAL,CAAqB,KAArB;;AACAP,cAAAA,KAAK,GAAGzC,KAAK,CAACa,GAAd;AACA+B,cAAAA,KAAK,GAAG,CAAR;AACD,aAJD,MAIO,IAAI,EAAEA,KAAK,GAAG7B,SAAS,CAACE,aAApB,KAAsCS,CAAC,KAAKR,EAAhD,EAAoD;AACzDyB,cAAAA,KAAK,GAAG,CAAR;;AACA,mBAAKK,eAAL,CAAqB,WAArB;;AACAP,cAAAA,KAAK,GAAGzC,KAAK,CAACI,kBAAd;AACD,aAJM,MAIA;AACL,qBAAOoD,CAAP;AACD;;AACD;AACD;;AAED,cAAI9B,CAAC,KAAKW,QAAQ,CAACM,KAAK,GAAG,CAAT,CAAlB,EAA+B;AAC7BA,YAAAA,KAAK,GAAG,CAAC,CAAT;AACD;;AACD,cAAIjB,CAAC,KAAKW,QAAQ,CAACM,KAAK,GAAG,CAAT,CAAlB,EAA+B;AAC7BA,YAAAA,KAAK;AACN;;AACD;;AACF,aAAK3C,KAAK,CAACI,kBAAX;AACEqC,UAAAA,KAAK,GAAGzC,KAAK,CAACK,YAAd;AACAiE,UAAAA,OAAO,CAAC,aAAD,CAAP;AACA3B,UAAAA,KAAK,GAAG,CAAR;;AACF,aAAK3C,KAAK,CAACK,YAAX;AACE,cAAIqB,CAAC,KAAKP,EAAV,EAAc;AACZqD,YAAAA,eAAe,CAAC,aAAD,CAAf;AACA/B,YAAAA,KAAK,GAAGzC,KAAK,CAACS,mBAAd;AACA;AACD;;AAEDkC,UAAAA,KAAK;;AACL,cAAIjB,CAAC,KAAKL,MAAV,EAAkB;AAChB;AACD;;AAED,cAAIK,CAAC,KAAKJ,KAAV,EAAiB;AACf,gBAAIqB,KAAK,KAAK,CAAd,EAAiB;AACf;AACA,qBAAOa,CAAP;AACD;;AACDiB,YAAAA,YAAY,CAAC,aAAD,EAAgB,IAAhB,CAAZ;AACAhC,YAAAA,KAAK,GAAGzC,KAAK,CAACM,kBAAd;AACA;AACD;;AAED+D,UAAAA,EAAE,GAAG5C,KAAK,CAACC,CAAD,CAAV;;AACA,cAAI2C,EAAE,GAAG9C,CAAL,IAAU8C,EAAE,GAAG7C,CAAnB,EAAsB;AACpB,mBAAOgC,CAAP;AACD;;AACD;;AACF,aAAKxD,KAAK,CAACM,kBAAX;AACE,cAAIoB,CAAC,KAAKN,KAAV,EAAiB;AACf;AACD;;AAEDkD,UAAAA,OAAO,CAAC,aAAD,CAAP;AACA7B,UAAAA,KAAK,GAAGzC,KAAK,CAACO,YAAd;;AACF,aAAKP,KAAK,CAACO,YAAX;AACE,cAAImB,CAAC,KAAKP,EAAV,EAAc;AACZsD,YAAAA,YAAY,CAAC,aAAD,EAAgB,IAAhB,CAAZ;;AACA,iBAAKzB,eAAL,CAAqB,WAArB;;AACAP,YAAAA,KAAK,GAAGzC,KAAK,CAACQ,wBAAd;AACD;;AACD;;AACF,aAAKR,KAAK,CAACQ,wBAAX;AACE,cAAIkB,CAAC,KAAKR,EAAV,EAAc;AACZ,mBAAOsC,CAAP;AACD;;AACDf,UAAAA,KAAK,GAAGzC,KAAK,CAACI,kBAAd;AACA;;AACF,aAAKJ,KAAK,CAACS,mBAAX;AACE,cAAIiB,CAAC,KAAKR,EAAV,EAAc;AACZ,mBAAOsC,CAAP;AACD;;AAED,eAAKR,eAAL,CAAqB,YAArB;;AACAP,UAAAA,KAAK,GAAGzC,KAAK,CAACU,eAAd;AACA;;AACF,aAAKV,KAAK,CAACU,eAAX;AACE+B,UAAAA,KAAK,GAAGzC,KAAK,CAACW,SAAd;AACA2D,UAAAA,OAAO,CAAC,UAAD,CAAP;;AACF,aAAKtE,KAAK,CAACW,SAAX;AACEuD,UAAAA,SAAS,GAAGvB,KAAZ;;AAEA,cAAIA,KAAK,KAAK,CAAd,EAAiB;AACf;AACAa,YAAAA,CAAC,IAAIY,WAAL;;AACA,mBAAOZ,CAAC,GAAG,KAAKhB,YAAT,IAAyB,EAAEuB,MAAM,CAACP,CAAD,CAAN,IAAalB,aAAf,CAAhC,EAA+D;AAC7DkB,cAAAA,CAAC,IAAIW,cAAL;AACD;;AACDX,YAAAA,CAAC,IAAIY,WAAL;AACA1C,YAAAA,CAAC,GAAGqC,MAAM,CAACP,CAAD,CAAV;AACD;;AAED,cAAIb,KAAK,GAAGN,QAAQ,CAACU,MAArB,EAA6B;AAC3B,gBAAIV,QAAQ,CAACM,KAAD,CAAR,KAAoBjB,CAAxB,EAA2B;AACzB,kBAAIiB,KAAK,KAAK,CAAd,EAAiB;AACf8B,gBAAAA,YAAY,CAAC,UAAD,EAAa,IAAb,CAAZ;AACD;;AACD9B,cAAAA,KAAK;AACN,aALD,MAKO;AACLA,cAAAA,KAAK,GAAG,CAAR;AACD;AACF,WATD,MASO,IAAIA,KAAK,KAAKN,QAAQ,CAACU,MAAvB,EAA+B;AACpCJ,YAAAA,KAAK;;AACL,gBAAIjB,CAAC,KAAKP,EAAV,EAAc;AACZ;AACAyB,cAAAA,KAAK,IAAI7B,SAAS,CAACC,aAAnB;AACD,aAHD,MAGO,IAAIU,CAAC,KAAKL,MAAV,EAAkB;AACvB;AACAuB,cAAAA,KAAK,IAAI7B,SAAS,CAACE,aAAnB;AACD,aAHM,MAGA;AACL0B,cAAAA,KAAK,GAAG,CAAR;AACD;AACF,WAXM,MAWA,IAAIA,KAAK,GAAG,CAAR,KAAcN,QAAQ,CAACU,MAA3B,EAAmC;AACxC,gBAAIH,KAAK,GAAG7B,SAAS,CAACC,aAAtB,EAAqC;AACnC2B,cAAAA,KAAK,GAAG,CAAR;;AACA,kBAAIjB,CAAC,KAAKR,EAAV,EAAc;AACZ;AACA0B,gBAAAA,KAAK,IAAI,CAAC7B,SAAS,CAACC,aAApB;;AACA,qBAAKgC,eAAL,CAAqB,SAArB;;AACA,qBAAKA,eAAL,CAAqB,WAArB;;AACAP,gBAAAA,KAAK,GAAGzC,KAAK,CAACI,kBAAd;AACA;AACD;AACF,aAVD,MAUO,IAAIwC,KAAK,GAAG7B,SAAS,CAACE,aAAtB,EAAqC;AAC1C,kBAAIS,CAAC,KAAKL,MAAV,EAAkB;AAChB,qBAAK2B,eAAL,CAAqB,SAArB;;AACA,qBAAKA,eAAL,CAAqB,KAArB;;AACAP,gBAAAA,KAAK,GAAGzC,KAAK,CAACa,GAAd;AACA+B,gBAAAA,KAAK,GAAG,CAAR;AACD,eALD,MAKO;AACLD,gBAAAA,KAAK,GAAG,CAAR;AACD;AACF,aATM,MASA;AACLA,cAAAA,KAAK,GAAG,CAAR;AACD;AACF;;AAED,cAAIA,KAAK,GAAG,CAAZ,EAAe;AACb;AACA;AACAJ,YAAAA,UAAU,CAACI,KAAK,GAAG,CAAT,CAAV,GAAwBjB,CAAxB;AACD,WAJD,MAIO,IAAIwC,SAAS,GAAG,CAAhB,EAAmB;AACxB;AACA;AACA,iBAAKlB,eAAL,CAAqB,UAArB,EAAiCT,UAAjC,EAA6C,CAA7C,EAAgD2B,SAAhD;;AACAA,YAAAA,SAAS,GAAG,CAAZ;AACAI,YAAAA,OAAO,CAAC,UAAD,CAAP,CALwB,CAOxB;AACA;;AACAd,YAAAA,CAAC;AACF;;AAED;;AACF,aAAKxD,KAAK,CAACa,GAAX;AACE;;AACF;AACE,iBAAO2C,CAAP;AAjLJ;AAmLD;;AAEDiB,IAAAA,YAAY,CAAC,aAAD,CAAZ;AACAA,IAAAA,YAAY,CAAC,aAAD,CAAZ;AACAA,IAAAA,YAAY,CAAC,UAAD,CAAZ;AAEA,SAAK9B,KAAL,GAAaA,KAAb;AACA,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKG,KAAL,GAAaA,KAAb;AAEAE,IAAAA,IAAI;AACJ,WAAO,KAAKN,YAAZ;AACD;;AAEDS,EAAAA,OAAO,GAAG;AACR,WAAQ,WAAUhB,eAAe,CAAC2C,aAAhB,CAA8B,KAAKnC,KAAnC,CAA0C,EAA5D;AACD;;AA5RqC,C,CA+RxC;;;AACAR,eAAe,CAAC2C,aAAhB,GAAiCC,WAAD,IAAiB;AAC/C;AACA,OAAK,MAAM7C,SAAX,IAAwBhC,KAAxB,EAA+B;AAC7B,UAAM8E,MAAM,GAAG9E,KAAK,CAACgC,SAAD,CAApB;AACA,QAAI8C,MAAM,KAAKD,WAAf,EAA4B,OAAO7C,SAAP;AAC7B;AACF,CAND;;AAQA+C,MAAM,CAACpD,OAAP,GAAiBE,MAAM,CAACmD,MAAP,CAAc/C,eAAd,EAA+B;AAAEL,EAAAA,MAAM,EAAED,OAAO,CAACC;AAAlB,CAA/B,CAAjB","sourcesContent":["/* eslint-disable no-fallthrough */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst { Transform } = require('stream');\nconst errors = require('../FormidableError.js');\n\nconst { FormidableError } = errors;\n\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++,\n};\n\nlet f = 1;\nconst FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: (f *= 2) };\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nfunction lower(c) {\n  return c | 0x20;\n}\n\nexports.STATES = {};\n\nObject.keys(STATE).forEach((stateName) => {\n  exports.STATES[stateName] = STATE[stateName];\n});\n\nclass MultipartParser extends Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n\n    this.globalOptions = { ...options };\n    this.index = null;\n    this.flags = 0;\n  }\n\n  _flush(done) {\n    if (\n      (this.state === STATE.HEADER_FIELD_START && this.index === 0) ||\n      (this.state === STATE.PART_DATA && this.index === this.boundary.length)\n    ) {\n      this._handleCallback('partEnd');\n      this._handleCallback('end');\n      done();\n    } else if (this.state !== STATE.END) {\n      done(\n        new FormidableError(\n          `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,\n          errors.malformedMultipart,\n          400,\n        ),\n      );\n    }\n  }\n\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  }\n\n  // eslint-disable-next-line max-params\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n    this.push({ name, buffer: buf, start, end });\n  }\n\n  // eslint-disable-next-line max-statements\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let { index, state, flags } = this;\n    const { lookbehind, boundary, boundaryChars } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n\n    const clearMarkSymbol = (name) => {\n      delete this[`${name}Mark`];\n    };\n\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n        clearMarkSymbol(name);\n      }\n    };\n\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          return i;\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return i;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              this._handleCallback('partBegin');\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              return i;\n            }\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return i;\n            }\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            return i;\n          }\n          break;\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n            this._handleCallback('headerEnd');\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n          state = STATE.HEADER_FIELD_START;\n          break;\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n\n          this._handleCallback('headersEnd');\n          state = STATE.PART_DATA_START;\n          break;\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n        case STATE.PART_DATA:\n          prevIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n                this._handleCallback('partEnd');\n                this._handleCallback('partBegin');\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n                this._handleCallback('end');\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n            prevIndex = 0;\n            setMark('partData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n\n          break;\n        case STATE.END:\n          break;\n        default:\n          return i;\n      }\n    }\n\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n\n    done();\n    return this.bufferLength;\n  }\n\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n}\n\n// eslint-disable-next-line consistent-return\nMultipartParser.stateToString = (stateNumber) => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\n\nmodule.exports = Object.assign(MultipartParser, { STATES: exports.STATES });\n"]},"metadata":{},"sourceType":"script"}