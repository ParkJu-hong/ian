{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst {\n  Stream\n} = require('stream');\n\nconst MultipartParser = require('../parsers/Multipart');\n\nconst errors = require('../FormidableError.js');\n\nconst {\n  FormidableError\n} = errors; // the `options` is also available through the `options` / `formidable.options`\n\nmodule.exports = function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable; // NOTE: we (currently) support both multipart/form-data and multipart/related\n\n  const multipart = /multipart/i.test(self.headers['content-type']);\n\n  if (multipart) {\n    const m = self.headers['content-type'].match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError('bad content-type header, no multipart boundary', errors.missingMultipartBoundary, 400);\n\n      self._error(err);\n    }\n  }\n}; // Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\n\n\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = 'multipart';\n    const parser = new MultipartParser(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n    parser.initWithBoundary(boundary); // eslint-disable-next-line max-statements, consistent-return\n\n    parser.on('data', _ref => {\n      let {\n        name,\n        buffer,\n        start,\n        end\n      } = _ref;\n\n      if (name === 'partBegin') {\n        part = new Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue; // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\n        const m = headerValue.match( // eslint-disable-next-line no-useless-escape\n        /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i);\n\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8':\n            {\n              const dataPropagation = ctx => {\n                if (ctx.name === 'partData') {\n                  part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n                }\n              };\n\n              const dataStopPropagation = ctx => {\n                if (ctx.name === 'partEnd') {\n                  part.emit('end');\n                  parser.off('data', dataPropagation);\n                  parser.off('data', dataStopPropagation);\n                }\n              };\n\n              parser.on('data', dataPropagation);\n              parser.on('data', dataStopPropagation);\n              break;\n            }\n\n          case 'base64':\n            {\n              const dataPropagation = ctx => {\n                if (ctx.name === 'partData') {\n                  part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString('ascii');\n                  /*\n                    four bytes (chars) in base64 converts to three bytes in binary\n                    encoding. So we should always work with a number of bytes that\n                    can be divided by 4, it will result in a number of buytes that\n                    can be divided vy 3.\n                    */\n\n                  const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                  part.emit('data', Buffer.from(part.transferBuffer.substring(0, offset), 'base64'));\n                  part.transferBuffer = part.transferBuffer.substring(offset);\n                }\n              };\n\n              const dataStopPropagation = ctx => {\n                if (ctx.name === 'partEnd') {\n                  part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                  part.emit('end');\n                  parser.off('data', dataPropagation);\n                  parser.off('data', dataStopPropagation);\n                }\n              };\n\n              parser.on('data', dataPropagation);\n              parser.on('data', dataStopPropagation);\n              break;\n            }\n\n          default:\n            return this._error(new FormidableError('unknown transfer-encoding', errors.unknownTransferEncoding, 501));\n        }\n\n        this.onPart(part);\n      } else if (name === 'end') {\n        this.ended = true;\n\n        this._maybeEnd();\n      }\n    });\n    this._parser = parser;\n  };\n}","map":{"version":3,"sources":["/Users/bagjuhong/Desktop/ian/node_modules/formidable/src/plugins/multipart.js"],"names":["Stream","require","MultipartParser","errors","FormidableError","module","exports","plugin","formidable","options","self","multipart","test","headers","m","match","initMultipart","createInitMultipart","call","err","missingMultipartBoundary","_error","boundary","type","parser","headerField","headerValue","part","initWithBoundary","on","name","buffer","start","end","readable","originalFilename","mimetype","transferEncoding","encoding","transferBuffer","toString","toLowerCase","_getFileName","dataPropagation","ctx","emit","slice","dataStopPropagation","off","offset","parseInt","length","Buffer","from","substring","unknownTransferEncoding","onPart","ended","_maybeEnd","_parser"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst { Stream } = require('stream');\nconst MultipartParser = require('../parsers/Multipart');\nconst errors = require('../FormidableError.js');\n\nconst { FormidableError } = errors;\n\n// the `options` is also available through the `options` / `formidable.options`\nmodule.exports = function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  // NOTE: we (currently) support both multipart/form-data and multipart/related\n  const multipart = /multipart/i.test(self.headers['content-type']);\n\n  if (multipart) {\n    const m = self.headers['content-type'].match(\n      /boundary=(?:\"([^\"]+)\"|([^;]+))/i,\n    );\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError(\n        'bad content-type header, no multipart boundary',\n        errors.missingMultipartBoundary,\n        400,\n      );\n      self._error(err);\n    }\n  }\n};\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = 'multipart';\n\n    const parser = new MultipartParser(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n\n    parser.initWithBoundary(boundary);\n\n    // eslint-disable-next-line max-statements, consistent-return\n    parser.on('data', ({ name, buffer, start, end }) => {\n      if (name === 'partBegin') {\n        part = new Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue;\n\n        // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n        const m = headerValue.match(\n          // eslint-disable-next-line no-useless-escape\n          /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i,\n        );\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          case 'base64': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.transferBuffer += ctx.buffer\n                  .slice(ctx.start, ctx.end)\n                  .toString('ascii');\n\n                /*\n                  four bytes (chars) in base64 converts to three bytes in binary\n                  encoding. So we should always work with a number of bytes that\n                  can be divided by 4, it will result in a number of buytes that\n                  can be divided vy 3.\n                  */\n                const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                part.emit(\n                  'data',\n                  Buffer.from(\n                    part.transferBuffer.substring(0, offset),\n                    'base64',\n                  ),\n                );\n                part.transferBuffer = part.transferBuffer.substring(offset);\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          default:\n            return this._error(\n              new FormidableError(\n                'unknown transfer-encoding',\n                errors.unknownTransferEncoding,\n                501,\n              ),\n            );\n        }\n\n        this.onPart(part);\n      } else if (name === 'end') {\n        this.ended = true;\n        this._maybeEnd();\n      }\n    });\n\n    this._parser = parser;\n  };\n}\n"]},"metadata":{},"sourceType":"script"}