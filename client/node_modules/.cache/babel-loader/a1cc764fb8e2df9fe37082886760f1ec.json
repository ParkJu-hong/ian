{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst {\n  Transform\n} = require('stream');\n\nconst querystring = require('querystring'); // This is a buffering parser, not quite as nice as the multipart one.\n// If I find time I'll rewrite this to be fully streaming as well\n\n\nclass QuerystringParser extends Transform {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      readableObjectMode: true\n    });\n    this.globalOptions = { ...options\n    };\n    this.buffer = '';\n    this.bufferLength = 0;\n  }\n\n  _transform(buffer, encoding, callback) {\n    this.buffer += buffer.toString('ascii');\n    this.bufferLength = this.buffer.length;\n    callback();\n  }\n\n  _flush(callback) {\n    const fields = querystring.parse(this.buffer, '&', '='); // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n    for (const key in fields) {\n      this.push({\n        key,\n        value: fields[key]\n      });\n    }\n\n    this.buffer = '';\n    callback();\n  }\n\n}\n\nmodule.exports = QuerystringParser;","map":{"version":3,"sources":["/Users/bagjuhong/Desktop/ian/node_modules/formidable/src/parsers/Querystring.js"],"names":["Transform","require","querystring","QuerystringParser","constructor","options","readableObjectMode","globalOptions","buffer","bufferLength","_transform","encoding","callback","toString","length","_flush","fields","parse","key","push","value","module","exports"],"mappings":"AAAA;AAEA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAgBC,OAAO,CAAC,QAAD,CAA7B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAD,CAA3B,C,CAEA;AACA;;;AACA,MAAME,iBAAN,SAAgCH,SAAhC,CAA0C;AACxCI,EAAAA,WAAW,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACxB,UAAM;AAAEC,MAAAA,kBAAkB,EAAE;AAAtB,KAAN;AACA,SAAKC,aAAL,GAAqB,EAAE,GAAGF;AAAL,KAArB;AACA,SAAKG,MAAL,GAAc,EAAd;AACA,SAAKC,YAAL,GAAoB,CAApB;AACD;;AAEDC,EAAAA,UAAU,CAACF,MAAD,EAASG,QAAT,EAAmBC,QAAnB,EAA6B;AACrC,SAAKJ,MAAL,IAAeA,MAAM,CAACK,QAAP,CAAgB,OAAhB,CAAf;AACA,SAAKJ,YAAL,GAAoB,KAAKD,MAAL,CAAYM,MAAhC;AACAF,IAAAA,QAAQ;AACT;;AAEDG,EAAAA,MAAM,CAACH,QAAD,EAAW;AACf,UAAMI,MAAM,GAAGd,WAAW,CAACe,KAAZ,CAAkB,KAAKT,MAAvB,EAA+B,GAA/B,EAAoC,GAApC,CAAf,CADe,CAEf;;AACA,SAAK,MAAMU,GAAX,IAAkBF,MAAlB,EAA0B;AACxB,WAAKG,IAAL,CAAU;AACRD,QAAAA,GADQ;AAERE,QAAAA,KAAK,EAAEJ,MAAM,CAACE,GAAD;AAFL,OAAV;AAID;;AACD,SAAKV,MAAL,GAAc,EAAd;AACAI,IAAAA,QAAQ;AACT;;AAzBuC;;AA4B1CS,MAAM,CAACC,OAAP,GAAiBnB,iBAAjB","sourcesContent":["/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst { Transform } = require('stream');\nconst querystring = require('querystring');\n\n// This is a buffering parser, not quite as nice as the multipart one.\n// If I find time I'll rewrite this to be fully streaming as well\nclass QuerystringParser extends Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.globalOptions = { ...options };\n    this.buffer = '';\n    this.bufferLength = 0;\n  }\n\n  _transform(buffer, encoding, callback) {\n    this.buffer += buffer.toString('ascii');\n    this.bufferLength = this.buffer.length;\n    callback();\n  }\n\n  _flush(callback) {\n    const fields = querystring.parse(this.buffer, '&', '=');\n    // eslint-disable-next-line no-restricted-syntax, guard-for-in\n    for (const key in fields) {\n      this.push({\n        key,\n        value: fields[key],\n      });\n    }\n    this.buffer = '';\n    callback();\n  }\n}\n\nmodule.exports = QuerystringParser;\n"]},"metadata":{},"sourceType":"script"}