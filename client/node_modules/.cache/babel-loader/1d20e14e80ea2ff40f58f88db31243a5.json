{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst hexoid = require('hexoid');\n\nconst once = require('once');\n\nconst dezalgo = require('dezalgo');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  StringDecoder\n} = require('string_decoder');\n\nconst qs = require('qs');\n\nconst toHexoId = hexoid(25);\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFileSize: 200 * 1024 * 1024,\n  minFileSize: 1,\n  allowEmptyFiles: true,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  multiples: false,\n  enabledPlugins: ['octetstream', 'querystring', 'multipart', 'json'],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter: function () {\n    return true;\n  }\n};\n\nconst PersistentFile = require('./PersistentFile');\n\nconst VolatileFile = require('./VolatileFile');\n\nconst DummyParser = require('./parsers/Dummy');\n\nconst MultipartParser = require('./parsers/Multipart');\n\nconst errors = require('./FormidableError.js');\n\nconst {\n  FormidableError\n} = errors;\n\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nclass IncomingForm extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.options = { ...DEFAULT_OPTIONS,\n      ...options\n    };\n    const dir = path.resolve(this.options.uploadDir || this.options.uploaddir || os.tmpdir());\n    this.uploaddir = dir;\n    this.uploadDir = dir; // initialize with null\n\n    ['error', 'headers', 'type', 'bytesExpected', 'bytesReceived', '_parser'].forEach(key => {\n      this[key] = null;\n    });\n\n    this._setUpRename();\n\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._fileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n    this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);\n\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError('expect at least 1 enabled builtin plugin, see options.enabledPlugins', errors.missingPlugin);\n    }\n\n    this.options.enabledPlugins.forEach(pluginName => {\n      const plgName = pluginName.toLowerCase(); // eslint-disable-next-line import/no-dynamic-require, global-require\n\n      this.use(require(path.join(__dirname, 'plugins', `${plgName}.js`)));\n    });\n\n    this._setUpMaxFields();\n  }\n\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError('.use: expect `plugin` to be a function', errors.pluginFunction);\n    }\n\n    this._plugins.push(plugin.bind(this));\n\n    return this;\n  }\n\n  parse(req, cb) {\n    this.pause = () => {\n      try {\n        req.pause();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    this.resume = () => {\n      try {\n        req.resume();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n\n        return false;\n      }\n\n      return true;\n    }; // Setup callback first, so we don't miss anything from data events emitted immediately.\n\n\n    if (cb) {\n      const callback = once(dezalgo(cb));\n      const fields = {};\n      let mockFields = '';\n      const files = {};\n      this.on('field', (name, value) => {\n        if (this.options.multiples && (this.type === 'multipart' || this.type === 'urlencoded')) {\n          const mObj = {\n            [name]: value\n          };\n          mockFields = mockFields ? `${mockFields}&${qs.stringify(mObj)}` : `${qs.stringify(mObj)}`;\n        } else {\n          fields[name] = value;\n        }\n      });\n      this.on('file', (name, file) => {\n        // TODO: too much nesting\n        if (this.options.multiples) {\n          if (hasOwnProp(files, name)) {\n            if (!Array.isArray(files[name])) {\n              files[name] = [files[name]];\n            }\n\n            files[name].push(file);\n          } else {\n            files[name] = file;\n          }\n        } else {\n          files[name] = file;\n        }\n      });\n      this.on('error', err => {\n        callback(err, fields, files);\n      });\n      this.on('end', () => {\n        if (this.options.multiples) {\n          Object.assign(fields, qs.parse(mockFields));\n        }\n\n        callback(null, fields, files);\n      });\n    } // Parse headers and setup the parser, ready to start listening for data.\n\n\n    this.writeHeaders(req.headers); // Start listening for data.\n\n    req.on('error', err => {\n      this._error(err);\n    }).on('aborted', () => {\n      this.emit('aborted');\n\n      this._error(new FormidableError('Request aborted', errors.aborted));\n    }).on('data', buffer => {\n      try {\n        this.write(buffer);\n      } catch (err) {\n        this._error(err);\n      }\n    }).on('end', () => {\n      if (this.error) {\n        return;\n      }\n\n      if (this._parser) {\n        this._parser.end();\n      }\n\n      this._maybeEnd();\n    });\n    return this;\n  }\n\n  writeHeaders(headers) {\n    this.headers = headers;\n\n    this._parseContentLength();\n\n    this._parseContentType();\n\n    if (!this._parser) {\n      this._error(new FormidableError('no parser found', errors.noParser, 415));\n\n      return;\n    }\n\n    this._parser.once('error', error => {\n      this._error(error);\n    });\n  }\n\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n\n    if (!this._parser) {\n      this._error(new FormidableError('uninitialized parser', errors.uninitializedParser));\n\n      return null;\n    }\n\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n    this._parser.write(buffer);\n\n    return this.bytesReceived;\n  }\n\n  pause() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  resume() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  onPart(part) {\n    // this method can be overwritten by the user\n    this._handlePart(part);\n  }\n\n  _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(new FormidableError(`the part.originalFilename should be string when it exists`, errors.filenameNotString));\n\n      return;\n    } // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n\n\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new StringDecoder(part.transferEncoding || this.options.encoding);\n      part.on('data', buffer => {\n        this._fieldsSize += buffer.length;\n\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(new FormidableError(`options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`, errors.maxFieldsSizeExceeded, 413));\n\n          return;\n        }\n\n        value += decoder.write(buffer);\n      });\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n\n    if (!this.options.filter(part)) {\n      return;\n    }\n\n    this._flushing += 1;\n\n    const newFilename = this._getNewName(part);\n\n    const filepath = this._joinDirectoryName(newFilename);\n\n    const file = this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype\n    });\n\n    file.on('error', err => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n    file.open();\n    this.openedFiles.push(file);\n    part.on('data', buffer => {\n      this._fileSize += buffer.length;\n\n      if (this._fileSize < this.options.minFileSize) {\n        this._error(new FormidableError(`options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${this._fileSize} bytes of file data`, errors.smallerThanMinFileSize, 400));\n\n        return;\n      }\n\n      if (this._fileSize > this.options.maxFileSize) {\n        this._error(new FormidableError(`options.maxFileSize (${this.options.maxFileSize} bytes) exceeded, received ${this._fileSize} bytes of file data`, errors.biggerThanMaxFileSize, 413));\n\n        return;\n      }\n\n      if (buffer.length === 0) {\n        return;\n      }\n\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && this._fileSize === 0) {\n        this._error(new FormidableError(`options.allowEmptyFiles is false, file size should be greather than 0`, errors.noEmptyFiles, 400));\n\n        return;\n      }\n\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n\n        this._maybeEnd();\n      });\n    });\n  } // eslint-disable-next-line max-statements\n\n\n  _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n\n    if (!this.headers['content-type']) {\n      this._error(new FormidableError('bad content-type header, no content-type', errors.missingContentType, 400));\n\n      return;\n    }\n\n    const results = [];\n\n    const _dummyParser = new DummyParser(this, this.options); // eslint-disable-next-line no-plusplus\n\n\n    for (let idx = 0; idx < this._plugins.length; idx++) {\n      const plugin = this._plugins[idx];\n      let pluginReturn = null;\n\n      try {\n        pluginReturn = plugin(this, this.options) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(`plugin on index ${idx} failed with: ${err.message}`, errors.pluginFailed, 500);\n        error.idx = idx;\n        throw error;\n      }\n\n      Object.assign(this, pluginReturn); // todo: use Set/Map and pass plugin name instead of the `idx` index\n\n      this.emit('plugin', idx, pluginReturn);\n      results.push(pluginReturn);\n    }\n\n    this.emit('pluginsResults', results); // NOTE: probably not needed, because we check options.enabledPlugins in the constructor\n    // if (results.length === 0 /* && results.length !== this._plugins.length */) {\n    //   this._error(\n    //     new Error(\n    //       `bad content-type header, unknown content-type: ${this.headers['content-type']}`,\n    //     ),\n    //   );\n    // }\n  }\n\n  _error(err) {\n    let eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'error';\n\n    // if (!err && this.error) {\n    //   this.emit('error', this.error);\n    //   return;\n    // }\n    if (this.error || this.ended) {\n      return;\n    }\n\n    this.error = err;\n    this.emit(eventName, err);\n\n    if (Array.isArray(this.openedFiles)) {\n      this.openedFiles.forEach(file => {\n        file.destroy();\n      });\n    }\n  }\n\n  _parseContentLength() {\n    this.bytesReceived = 0;\n\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n\n  _newParser() {\n    return new MultipartParser(this.options);\n  }\n\n  _newFile(_ref) {\n    let {\n      filepath,\n      originalFilename,\n      mimetype,\n      newFilename\n    } = _ref;\n    return this.options.fileWriteStreamHandler ? new VolatileFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      createFileWriteStream: this.options.fileWriteStreamHandler,\n      hashAlgorithm: this.options.hashAlgorithm\n    }) : new PersistentFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      hashAlgorithm: this.options.hashAlgorithm\n    });\n  }\n\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i);\n    if (!m) return null;\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) => String.fromCharCode(code));\n    return originalFilename;\n  }\n\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    const extname = path.extname(basename).replace(/(\\.[a-z0-9]+).*/i, '$1');\n\n    if (firstDot === lastDot) {\n      return extname;\n    }\n\n    return basename.slice(firstDot, lastDot) + extname;\n  }\n\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name); // prevent directory traversal attacks\n\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n\n    return newPath;\n  }\n\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n\n    if (hasRename) {\n      this._getNewName = part => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n\n        if (part.originalFilename) {\n          // can be null\n          ({\n            ext,\n            name\n          } = path.parse(part.originalFilename));\n\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = part => {\n        const name = toHexoId();\n\n        if (part && this.options.keepExtensions) {\n          const originalFilename = typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n\n        return name;\n      };\n    }\n  }\n\n  _setUpMaxFields() {\n    if (this.options.maxFields !== 0) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n\n        if (fieldsCount > this.options.maxFields) {\n          this._error(new FormidableError(`options.maxFields (${this.options.maxFields}) exceeded`, errors.maxFieldsExceeded, 413));\n        }\n      });\n    }\n  }\n\n  _maybeEnd() {\n    // console.log('ended', this.ended);\n    // console.log('_flushing', this._flushing);\n    // console.log('error', this.error);\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n\n    this.emit('end');\n  }\n\n}\n\nIncomingForm.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\nmodule.exports = IncomingForm;","map":{"version":3,"sources":["/Users/bagjuhong/Desktop/ian/node_modules/formidable/src/Formidable.js"],"names":["os","require","path","hexoid","once","dezalgo","EventEmitter","StringDecoder","qs","toHexoId","DEFAULT_OPTIONS","maxFields","maxFieldsSize","maxFileSize","minFileSize","allowEmptyFiles","keepExtensions","encoding","hashAlgorithm","uploadDir","tmpdir","multiples","enabledPlugins","fileWriteStreamHandler","defaultInvalidName","filter","PersistentFile","VolatileFile","DummyParser","MultipartParser","errors","FormidableError","hasOwnProp","obj","key","Object","prototype","hasOwnProperty","call","IncomingForm","constructor","options","dir","resolve","uploaddir","forEach","_setUpRename","_flushing","_fieldsSize","_fileSize","_plugins","openedFiles","concat","Boolean","length","missingPlugin","pluginName","plgName","toLowerCase","use","join","__dirname","_setUpMaxFields","plugin","pluginFunction","push","bind","parse","req","cb","pause","err","ended","_error","resume","callback","fields","mockFields","files","on","name","value","type","mObj","stringify","file","Array","isArray","assign","writeHeaders","headers","emit","aborted","buffer","write","error","_parser","end","_maybeEnd","_parseContentLength","_parseContentType","noParser","uninitializedParser","bytesReceived","bytesExpected","onPart","part","_handlePart","originalFilename","filenameNotString","mimetype","decoder","transferEncoding","maxFieldsSizeExceeded","newFilename","_getNewName","filepath","_joinDirectoryName","_newFile","open","smallerThanMinFileSize","biggerThanMaxFileSize","noEmptyFiles","missingContentType","results","_dummyParser","idx","pluginReturn","message","pluginFailed","eventName","destroy","parseInt","undefined","_newParser","createFileWriteStream","_getFileName","headerValue","m","match","substr","lastIndexOf","replace","_","code","String","fromCharCode","_getExtension","str","basename","firstDot","indexOf","lastDot","extname","slice","newPath","startsWith","hasRename","filename","ext","fieldsCount","maxFieldsExceeded","module","exports"],"mappings":"AAAA;;AACA;AAEA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAmBL,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAoBN,OAAO,CAAC,gBAAD,CAAjC;;AACA,MAAMO,EAAE,GAAGP,OAAO,CAAC,IAAD,CAAlB;;AAEA,MAAMQ,QAAQ,GAAGN,MAAM,CAAC,EAAD,CAAvB;AACA,MAAMO,eAAe,GAAG;AACtBC,EAAAA,SAAS,EAAE,IADW;AAEtBC,EAAAA,aAAa,EAAE,KAAK,IAAL,GAAY,IAFL;AAGtBC,EAAAA,WAAW,EAAE,MAAM,IAAN,GAAa,IAHJ;AAItBC,EAAAA,WAAW,EAAE,CAJS;AAKtBC,EAAAA,eAAe,EAAE,IALK;AAMtBC,EAAAA,cAAc,EAAE,KANM;AAOtBC,EAAAA,QAAQ,EAAE,OAPY;AAQtBC,EAAAA,aAAa,EAAE,KARO;AAStBC,EAAAA,SAAS,EAAEnB,EAAE,CAACoB,MAAH,EATW;AAUtBC,EAAAA,SAAS,EAAE,KAVW;AAWtBC,EAAAA,cAAc,EAAE,CAAC,aAAD,EAAgB,aAAhB,EAA+B,WAA/B,EAA4C,MAA5C,CAXM;AAYtBC,EAAAA,sBAAsB,EAAE,IAZF;AAatBC,EAAAA,kBAAkB,EAAE,cAbE;AActBC,EAAAA,MAAM,EAAE,YAAY;AAClB,WAAO,IAAP;AACD;AAhBqB,CAAxB;;AAmBA,MAAMC,cAAc,GAAGzB,OAAO,CAAC,kBAAD,CAA9B;;AACA,MAAM0B,YAAY,GAAG1B,OAAO,CAAC,gBAAD,CAA5B;;AACA,MAAM2B,WAAW,GAAG3B,OAAO,CAAC,iBAAD,CAA3B;;AACA,MAAM4B,eAAe,GAAG5B,OAAO,CAAC,qBAAD,CAA/B;;AACA,MAAM6B,MAAM,GAAG7B,OAAO,CAAC,sBAAD,CAAtB;;AAEA,MAAM;AAAE8B,EAAAA;AAAF,IAAsBD,MAA5B;;AAEA,SAASE,UAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;AAC5B,SAAOC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,GAArC,EAA0CC,GAA1C,CAAP;AACD;;AAED,MAAMK,YAAN,SAA2BjC,YAA3B,CAAwC;AACtCkC,EAAAA,WAAW,GAAe;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACxB;AAEA,SAAKA,OAAL,GAAe,EAAE,GAAG/B,eAAL;AAAsB,SAAG+B;AAAzB,KAAf;AAEA,UAAMC,GAAG,GAAGxC,IAAI,CAACyC,OAAL,CACV,KAAKF,OAAL,CAAatB,SAAb,IAA0B,KAAKsB,OAAL,CAAaG,SAAvC,IAAoD5C,EAAE,CAACoB,MAAH,EAD1C,CAAZ;AAIA,SAAKwB,SAAL,GAAiBF,GAAjB;AACA,SAAKvB,SAAL,GAAiBuB,GAAjB,CAVwB,CAYxB;;AACA,KACE,OADF,EAEE,SAFF,EAGE,MAHF,EAIE,eAJF,EAKE,eALF,EAME,SANF,EAOEG,OAPF,CAOWX,GAAD,IAAS;AACjB,WAAKA,GAAL,IAAY,IAAZ;AACD,KATD;;AAWA,SAAKY,YAAL;;AAEA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKC,WAAL,GAAmB,EAAnB;AAEA,SAAKV,OAAL,CAAanB,cAAb,GAA8B,GAC3B8B,MAD2B,CACpB,KAAKX,OAAL,CAAanB,cADO,EAE3BG,MAF2B,CAEpB4B,OAFoB,CAA9B;;AAIA,QAAI,KAAKZ,OAAL,CAAanB,cAAb,CAA4BgC,MAA5B,KAAuC,CAA3C,EAA8C;AAC5C,YAAM,IAAIvB,eAAJ,CACJ,sEADI,EAEJD,MAAM,CAACyB,aAFH,CAAN;AAID;;AAED,SAAKd,OAAL,CAAanB,cAAb,CAA4BuB,OAA5B,CAAqCW,UAAD,IAAgB;AAClD,YAAMC,OAAO,GAAGD,UAAU,CAACE,WAAX,EAAhB,CADkD,CAElD;;AACA,WAAKC,GAAL,CAAS1D,OAAO,CAACC,IAAI,CAAC0D,IAAL,CAAUC,SAAV,EAAqB,SAArB,EAAiC,GAAEJ,OAAQ,KAA3C,CAAD,CAAhB;AACD,KAJD;;AAMA,SAAKK,eAAL;AACD;;AAEDH,EAAAA,GAAG,CAACI,MAAD,EAAS;AACV,QAAI,OAAOA,MAAP,KAAkB,UAAtB,EAAkC;AAChC,YAAM,IAAIhC,eAAJ,CACJ,wCADI,EAEJD,MAAM,CAACkC,cAFH,CAAN;AAID;;AACD,SAAKd,QAAL,CAAce,IAAd,CAAmBF,MAAM,CAACG,IAAP,CAAY,IAAZ,CAAnB;;AACA,WAAO,IAAP;AACD;;AAEDC,EAAAA,KAAK,CAACC,GAAD,EAAMC,EAAN,EAAU;AACb,SAAKC,KAAL,GAAa,MAAM;AACjB,UAAI;AACFF,QAAAA,GAAG,CAACE,KAAJ;AACD,OAFD,CAEE,OAAOC,GAAP,EAAY;AACZ;AACA,YAAI,CAAC,KAAKC,KAAV,EAAiB;AACf;AACA,eAAKC,MAAL,CAAYF,GAAZ;AACD;;AACD,eAAO,KAAP;AACD;;AACD,aAAO,IAAP;AACD,KAZD;;AAcA,SAAKG,MAAL,GAAc,MAAM;AAClB,UAAI;AACFN,QAAAA,GAAG,CAACM,MAAJ;AACD,OAFD,CAEE,OAAOH,GAAP,EAAY;AACZ;AACA,YAAI,CAAC,KAAKC,KAAV,EAAiB;AACf;AACA,eAAKC,MAAL,CAAYF,GAAZ;AACD;;AACD,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD,KAbD,CAfa,CA8Bb;;;AACA,QAAIF,EAAJ,EAAQ;AACN,YAAMM,QAAQ,GAAGvE,IAAI,CAACC,OAAO,CAACgE,EAAD,CAAR,CAArB;AACA,YAAMO,MAAM,GAAG,EAAf;AACA,UAAIC,UAAU,GAAG,EAAjB;AACA,YAAMC,KAAK,GAAG,EAAd;AAEA,WAAKC,EAAL,CAAQ,OAAR,EAAiB,CAACC,IAAD,EAAOC,KAAP,KAAiB;AAChC,YACE,KAAKxC,OAAL,CAAapB,SAAb,KACC,KAAK6D,IAAL,KAAc,WAAd,IAA6B,KAAKA,IAAL,KAAc,YAD5C,CADF,EAGE;AACA,gBAAMC,IAAI,GAAG;AAAE,aAACH,IAAD,GAAQC;AAAV,WAAb;AACAJ,UAAAA,UAAU,GAAGA,UAAU,GAClB,GAAEA,UAAW,IAAGrE,EAAE,CAAC4E,SAAH,CAAaD,IAAb,CAAmB,EADjB,GAElB,GAAE3E,EAAE,CAAC4E,SAAH,CAAaD,IAAb,CAAmB,EAF1B;AAGD,SARD,MAQO;AACLP,UAAAA,MAAM,CAACI,IAAD,CAAN,GAAeC,KAAf;AACD;AACF,OAZD;AAaA,WAAKF,EAAL,CAAQ,MAAR,EAAgB,CAACC,IAAD,EAAOK,IAAP,KAAgB;AAC9B;AACA,YAAI,KAAK5C,OAAL,CAAapB,SAAjB,EAA4B;AAC1B,cAAIW,UAAU,CAAC8C,KAAD,EAAQE,IAAR,CAAd,EAA6B;AAC3B,gBAAI,CAACM,KAAK,CAACC,OAAN,CAAcT,KAAK,CAACE,IAAD,CAAnB,CAAL,EAAiC;AAC/BF,cAAAA,KAAK,CAACE,IAAD,CAAL,GAAc,CAACF,KAAK,CAACE,IAAD,CAAN,CAAd;AACD;;AACDF,YAAAA,KAAK,CAACE,IAAD,CAAL,CAAYf,IAAZ,CAAiBoB,IAAjB;AACD,WALD,MAKO;AACLP,YAAAA,KAAK,CAACE,IAAD,CAAL,GAAcK,IAAd;AACD;AACF,SATD,MASO;AACLP,UAAAA,KAAK,CAACE,IAAD,CAAL,GAAcK,IAAd;AACD;AACF,OAdD;AAeA,WAAKN,EAAL,CAAQ,OAAR,EAAkBR,GAAD,IAAS;AACxBI,QAAAA,QAAQ,CAACJ,GAAD,EAAMK,MAAN,EAAcE,KAAd,CAAR;AACD,OAFD;AAGA,WAAKC,EAAL,CAAQ,KAAR,EAAe,MAAM;AACnB,YAAI,KAAKtC,OAAL,CAAapB,SAAjB,EAA4B;AAC1Bc,UAAAA,MAAM,CAACqD,MAAP,CAAcZ,MAAd,EAAsBpE,EAAE,CAAC2D,KAAH,CAASU,UAAT,CAAtB;AACD;;AACDF,QAAAA,QAAQ,CAAC,IAAD,EAAOC,MAAP,EAAeE,KAAf,CAAR;AACD,OALD;AAMD,KA1EY,CA4Eb;;;AACA,SAAKW,YAAL,CAAkBrB,GAAG,CAACsB,OAAtB,EA7Ea,CA+Eb;;AACAtB,IAAAA,GAAG,CACAW,EADH,CACM,OADN,EACgBR,GAAD,IAAS;AACpB,WAAKE,MAAL,CAAYF,GAAZ;AACD,KAHH,EAIGQ,EAJH,CAIM,SAJN,EAIiB,MAAM;AACnB,WAAKY,IAAL,CAAU,SAAV;;AACA,WAAKlB,MAAL,CAAY,IAAI1C,eAAJ,CAAoB,iBAApB,EAAuCD,MAAM,CAAC8D,OAA9C,CAAZ;AACD,KAPH,EAQGb,EARH,CAQM,MARN,EAQec,MAAD,IAAY;AACtB,UAAI;AACF,aAAKC,KAAL,CAAWD,MAAX;AACD,OAFD,CAEE,OAAOtB,GAAP,EAAY;AACZ,aAAKE,MAAL,CAAYF,GAAZ;AACD;AACF,KAdH,EAeGQ,EAfH,CAeM,KAfN,EAea,MAAM;AACf,UAAI,KAAKgB,KAAT,EAAgB;AACd;AACD;;AACD,UAAI,KAAKC,OAAT,EAAkB;AAChB,aAAKA,OAAL,CAAaC,GAAb;AACD;;AACD,WAAKC,SAAL;AACD,KAvBH;AAyBA,WAAO,IAAP;AACD;;AAEDT,EAAAA,YAAY,CAACC,OAAD,EAAU;AACpB,SAAKA,OAAL,GAAeA,OAAf;;AACA,SAAKS,mBAAL;;AACA,SAAKC,iBAAL;;AAEA,QAAI,CAAC,KAAKJ,OAAV,EAAmB;AACjB,WAAKvB,MAAL,CACE,IAAI1C,eAAJ,CACE,iBADF,EAEED,MAAM,CAACuE,QAFT,EAGE,GAHF,CADF;;AAOA;AACD;;AAED,SAAKL,OAAL,CAAa5F,IAAb,CAAkB,OAAlB,EAA4B2F,KAAD,IAAW;AACpC,WAAKtB,MAAL,CAAYsB,KAAZ;AACD,KAFD;AAGD;;AAEDD,EAAAA,KAAK,CAACD,MAAD,EAAS;AACZ,QAAI,KAAKE,KAAT,EAAgB;AACd,aAAO,IAAP;AACD;;AACD,QAAI,CAAC,KAAKC,OAAV,EAAmB;AACjB,WAAKvB,MAAL,CACE,IAAI1C,eAAJ,CAAoB,sBAApB,EAA4CD,MAAM,CAACwE,mBAAnD,CADF;;AAGA,aAAO,IAAP;AACD;;AAED,SAAKC,aAAL,IAAsBV,MAAM,CAACvC,MAA7B;AACA,SAAKqC,IAAL,CAAU,UAAV,EAAsB,KAAKY,aAA3B,EAA0C,KAAKC,aAA/C;;AAEA,SAAKR,OAAL,CAAaF,KAAb,CAAmBD,MAAnB;;AAEA,WAAO,KAAKU,aAAZ;AACD;;AAEDjC,EAAAA,KAAK,GAAG;AACN;AACA,WAAO,KAAP;AACD;;AAEDI,EAAAA,MAAM,GAAG;AACP;AACA,WAAO,KAAP;AACD;;AAED+B,EAAAA,MAAM,CAACC,IAAD,EAAO;AACX;AACA,SAAKC,WAAL,CAAiBD,IAAjB;AACD;;AAEDC,EAAAA,WAAW,CAACD,IAAD,EAAO;AAChB,QAAIA,IAAI,CAACE,gBAAL,IAAyB,OAAOF,IAAI,CAACE,gBAAZ,KAAiC,QAA9D,EAAwE;AACtE,WAAKnC,MAAL,CACE,IAAI1C,eAAJ,CACG,2DADH,EAEED,MAAM,CAAC+E,iBAFT,CADF;;AAMA;AACD,KATe,CAWhB;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AACA,QAAI,CAACH,IAAI,CAACI,QAAV,EAAoB;AAClB,UAAI7B,KAAK,GAAG,EAAZ;AACA,YAAM8B,OAAO,GAAG,IAAIxG,aAAJ,CACdmG,IAAI,CAACM,gBAAL,IAAyB,KAAKvE,OAAL,CAAaxB,QADxB,CAAhB;AAIAyF,MAAAA,IAAI,CAAC3B,EAAL,CAAQ,MAAR,EAAiBc,MAAD,IAAY;AAC1B,aAAK7C,WAAL,IAAoB6C,MAAM,CAACvC,MAA3B;;AACA,YAAI,KAAKN,WAAL,GAAmB,KAAKP,OAAL,CAAa7B,aAApC,EAAmD;AACjD,eAAK6D,MAAL,CACE,IAAI1C,eAAJ,CACG,0BAAyB,KAAKU,OAAL,CAAa7B,aAAc,8BAA6B,KAAKoC,WAAY,sBADrG,EAEElB,MAAM,CAACmF,qBAFT,EAGE,GAHF,CADF;;AAOA;AACD;;AACDhC,QAAAA,KAAK,IAAI8B,OAAO,CAACjB,KAAR,CAAcD,MAAd,CAAT;AACD,OAbD;AAeAa,MAAAA,IAAI,CAAC3B,EAAL,CAAQ,KAAR,EAAe,MAAM;AACnB,aAAKY,IAAL,CAAU,OAAV,EAAmBe,IAAI,CAAC1B,IAAxB,EAA8BC,KAA9B;AACD,OAFD;AAGA;AACD;;AAED,QAAI,CAAC,KAAKxC,OAAL,CAAahB,MAAb,CAAoBiF,IAApB,CAAL,EAAgC;AAC9B;AACD;;AAED,SAAK3D,SAAL,IAAkB,CAAlB;;AAEA,UAAMmE,WAAW,GAAG,KAAKC,WAAL,CAAiBT,IAAjB,CAApB;;AACA,UAAMU,QAAQ,GAAG,KAAKC,kBAAL,CAAwBH,WAAxB,CAAjB;;AACA,UAAM7B,IAAI,GAAG,KAAKiC,QAAL,CAAc;AACzBJ,MAAAA,WADyB;AAEzBE,MAAAA,QAFyB;AAGzBR,MAAAA,gBAAgB,EAAEF,IAAI,CAACE,gBAHE;AAIzBE,MAAAA,QAAQ,EAAEJ,IAAI,CAACI;AAJU,KAAd,CAAb;;AAMAzB,IAAAA,IAAI,CAACN,EAAL,CAAQ,OAAR,EAAkBR,GAAD,IAAS;AACxB,WAAKE,MAAL,CAAYF,GAAZ;AACD,KAFD;AAGA,SAAKoB,IAAL,CAAU,WAAV,EAAuBe,IAAI,CAAC1B,IAA5B,EAAkCK,IAAlC;AAEAA,IAAAA,IAAI,CAACkC,IAAL;AACA,SAAKpE,WAAL,CAAiBc,IAAjB,CAAsBoB,IAAtB;AAEAqB,IAAAA,IAAI,CAAC3B,EAAL,CAAQ,MAAR,EAAiBc,MAAD,IAAY;AAC1B,WAAK5C,SAAL,IAAkB4C,MAAM,CAACvC,MAAzB;;AACA,UAAI,KAAKL,SAAL,GAAiB,KAAKR,OAAL,CAAa3B,WAAlC,EAA+C;AAC7C,aAAK2D,MAAL,CACE,IAAI1C,eAAJ,CACG,wBAAuB,KAAKU,OAAL,CAAa3B,WAAY,8BAA6B,KAAKmC,SAAU,qBAD/F,EAEEnB,MAAM,CAAC0F,sBAFT,EAGE,GAHF,CADF;;AAOA;AACD;;AACD,UAAI,KAAKvE,SAAL,GAAiB,KAAKR,OAAL,CAAa5B,WAAlC,EAA+C;AAC7C,aAAK4D,MAAL,CACE,IAAI1C,eAAJ,CACG,wBAAuB,KAAKU,OAAL,CAAa5B,WAAY,8BAA6B,KAAKoC,SAAU,qBAD/F,EAEEnB,MAAM,CAAC2F,qBAFT,EAGE,GAHF,CADF;;AAOA;AACD;;AACD,UAAI5B,MAAM,CAACvC,MAAP,KAAkB,CAAtB,EAAyB;AACvB;AACD;;AACD,WAAKgB,KAAL;AACAe,MAAAA,IAAI,CAACS,KAAL,CAAWD,MAAX,EAAmB,MAAM;AACvB,aAAKnB,MAAL;AACD,OAFD;AAGD,KA7BD;AA+BAgC,IAAAA,IAAI,CAAC3B,EAAL,CAAQ,KAAR,EAAe,MAAM;AACnB,UAAI,CAAC,KAAKtC,OAAL,CAAa1B,eAAd,IAAiC,KAAKkC,SAAL,KAAmB,CAAxD,EAA2D;AACzD,aAAKwB,MAAL,CACE,IAAI1C,eAAJ,CACG,uEADH,EAEED,MAAM,CAAC4F,YAFT,EAGE,GAHF,CADF;;AAOA;AACD;;AAEDrC,MAAAA,IAAI,CAACY,GAAL,CAAS,MAAM;AACb,aAAKlD,SAAL,IAAkB,CAAlB;AACA,aAAK4C,IAAL,CAAU,MAAV,EAAkBe,IAAI,CAAC1B,IAAvB,EAA6BK,IAA7B;;AACA,aAAKa,SAAL;AACD,OAJD;AAKD,KAjBD;AAkBD,GA1VqC,CA4VtC;;;AACAE,EAAAA,iBAAiB,GAAG;AAClB,QAAI,KAAKI,aAAL,KAAuB,CAA3B,EAA8B;AAC5B,WAAKR,OAAL,GAAe,IAAIpE,WAAJ,CAAgB,IAAhB,EAAsB,KAAKa,OAA3B,CAAf;AACA;AACD;;AAED,QAAI,CAAC,KAAKiD,OAAL,CAAa,cAAb,CAAL,EAAmC;AACjC,WAAKjB,MAAL,CACE,IAAI1C,eAAJ,CACE,0CADF,EAEED,MAAM,CAAC6F,kBAFT,EAGE,GAHF,CADF;;AAOA;AACD;;AAED,UAAMC,OAAO,GAAG,EAAhB;;AACA,UAAMC,YAAY,GAAG,IAAIjG,WAAJ,CAAgB,IAAhB,EAAsB,KAAKa,OAA3B,CAArB,CAlBkB,CAoBlB;;;AACA,SAAK,IAAIqF,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,KAAK5E,QAAL,CAAcI,MAAtC,EAA8CwE,GAAG,EAAjD,EAAqD;AACnD,YAAM/D,MAAM,GAAG,KAAKb,QAAL,CAAc4E,GAAd,CAAf;AAEA,UAAIC,YAAY,GAAG,IAAnB;;AAEA,UAAI;AACFA,QAAAA,YAAY,GAAGhE,MAAM,CAAC,IAAD,EAAO,KAAKtB,OAAZ,CAAN,IAA8B,IAA7C;AACD,OAFD,CAEE,OAAO8B,GAAP,EAAY;AACZ;AACA;AACA,cAAMwB,KAAK,GAAG,IAAIhE,eAAJ,CACX,mBAAkB+F,GAAI,iBAAgBvD,GAAG,CAACyD,OAAQ,EADvC,EAEZlG,MAAM,CAACmG,YAFK,EAGZ,GAHY,CAAd;AAKAlC,QAAAA,KAAK,CAAC+B,GAAN,GAAYA,GAAZ;AACA,cAAM/B,KAAN;AACD;;AAED5D,MAAAA,MAAM,CAACqD,MAAP,CAAc,IAAd,EAAoBuC,YAApB,EAnBmD,CAqBnD;;AACA,WAAKpC,IAAL,CAAU,QAAV,EAAoBmC,GAApB,EAAyBC,YAAzB;AACAH,MAAAA,OAAO,CAAC3D,IAAR,CAAa8D,YAAb;AACD;;AAED,SAAKpC,IAAL,CAAU,gBAAV,EAA4BiC,OAA5B,EA/CkB,CAiDlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAEDnD,EAAAA,MAAM,CAACF,GAAD,EAA2B;AAAA,QAArB2D,SAAqB,uEAAT,OAAS;;AAC/B;AACA;AACA;AACA;AACA,QAAI,KAAKnC,KAAL,IAAc,KAAKvB,KAAvB,EAA8B;AAC5B;AACD;;AAED,SAAKuB,KAAL,GAAaxB,GAAb;AACA,SAAKoB,IAAL,CAAUuC,SAAV,EAAqB3D,GAArB;;AAEA,QAAIe,KAAK,CAACC,OAAN,CAAc,KAAKpC,WAAnB,CAAJ,EAAqC;AACnC,WAAKA,WAAL,CAAiBN,OAAjB,CAA0BwC,IAAD,IAAU;AACjCA,QAAAA,IAAI,CAAC8C,OAAL;AACD,OAFD;AAGD;AACF;;AAEDhC,EAAAA,mBAAmB,GAAG;AACpB,SAAKI,aAAL,GAAqB,CAArB;;AACA,QAAI,KAAKb,OAAL,CAAa,gBAAb,CAAJ,EAAoC;AAClC,WAAKc,aAAL,GAAqB4B,QAAQ,CAAC,KAAK1C,OAAL,CAAa,gBAAb,CAAD,EAAiC,EAAjC,CAA7B;AACD,KAFD,MAEO,IAAI,KAAKA,OAAL,CAAa,mBAAb,MAAsC2C,SAA1C,EAAqD;AAC1D,WAAK7B,aAAL,GAAqB,CAArB;AACD;;AAED,QAAI,KAAKA,aAAL,KAAuB,IAA3B,EAAiC;AAC/B,WAAKb,IAAL,CAAU,UAAV,EAAsB,KAAKY,aAA3B,EAA0C,KAAKC,aAA/C;AACD;AACF;;AAED8B,EAAAA,UAAU,GAAG;AACX,WAAO,IAAIzG,eAAJ,CAAoB,KAAKY,OAAzB,CAAP;AACD;;AAED6E,EAAAA,QAAQ,OAAwD;AAAA,QAAvD;AAAEF,MAAAA,QAAF;AAAYR,MAAAA,gBAAZ;AAA8BE,MAAAA,QAA9B;AAAwCI,MAAAA;AAAxC,KAAuD;AAC9D,WAAO,KAAKzE,OAAL,CAAalB,sBAAb,GACH,IAAII,YAAJ,CAAiB;AACfuF,MAAAA,WADe;AAEfE,MAAAA,QAFe;AAGfR,MAAAA,gBAHe;AAIfE,MAAAA,QAJe;AAKfyB,MAAAA,qBAAqB,EAAE,KAAK9F,OAAL,CAAalB,sBALrB;AAMfL,MAAAA,aAAa,EAAE,KAAKuB,OAAL,CAAavB;AANb,KAAjB,CADG,GASH,IAAIQ,cAAJ,CAAmB;AACjBwF,MAAAA,WADiB;AAEjBE,MAAAA,QAFiB;AAGjBR,MAAAA,gBAHiB;AAIjBE,MAAAA,QAJiB;AAKjB5F,MAAAA,aAAa,EAAE,KAAKuB,OAAL,CAAavB;AALX,KAAnB,CATJ;AAgBD;;AAEDsH,EAAAA,YAAY,CAACC,WAAD,EAAc;AACxB;AACA,UAAMC,CAAC,GAAGD,WAAW,CAACE,KAAZ,CACR,0DADQ,CAAV;AAGA,QAAI,CAACD,CAAL,EAAQ,OAAO,IAAP;AAER,UAAMC,KAAK,GAAGD,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAT,IAAgB,EAA9B;AACA,QAAI9B,gBAAgB,GAAG+B,KAAK,CAACC,MAAN,CAAaD,KAAK,CAACE,WAAN,CAAkB,IAAlB,IAA0B,CAAvC,CAAvB;AACAjC,IAAAA,gBAAgB,GAAGA,gBAAgB,CAACkC,OAAjB,CAAyB,MAAzB,EAAiC,GAAjC,CAAnB;AACAlC,IAAAA,gBAAgB,GAAGA,gBAAgB,CAACkC,OAAjB,CAAyB,eAAzB,EAA0C,CAACC,CAAD,EAAIC,IAAJ,KAC3DC,MAAM,CAACC,YAAP,CAAoBF,IAApB,CADiB,CAAnB;AAIA,WAAOpC,gBAAP;AACD;;AAEDuC,EAAAA,aAAa,CAACC,GAAD,EAAM;AACjB,QAAI,CAACA,GAAL,EAAU;AACR,aAAO,EAAP;AACD;;AAED,UAAMC,QAAQ,GAAGnJ,IAAI,CAACmJ,QAAL,CAAcD,GAAd,CAAjB;AACA,UAAME,QAAQ,GAAGD,QAAQ,CAACE,OAAT,CAAiB,GAAjB,CAAjB;AACA,UAAMC,OAAO,GAAGH,QAAQ,CAACR,WAAT,CAAqB,GAArB,CAAhB;AACA,UAAMY,OAAO,GAAGvJ,IAAI,CAACuJ,OAAL,CAAaJ,QAAb,EAAuBP,OAAvB,CAA+B,kBAA/B,EAAmD,IAAnD,CAAhB;;AAEA,QAAIQ,QAAQ,KAAKE,OAAjB,EAA0B;AACxB,aAAOC,OAAP;AACD;;AAED,WAAOJ,QAAQ,CAACK,KAAT,CAAeJ,QAAf,EAAyBE,OAAzB,IAAoCC,OAA3C;AACD;;AAIDpC,EAAAA,kBAAkB,CAACrC,IAAD,EAAO;AACvB,UAAM2E,OAAO,GAAGzJ,IAAI,CAAC0D,IAAL,CAAU,KAAKzC,SAAf,EAA0B6D,IAA1B,CAAhB,CADuB,CAGvB;;AACA,QAAI,CAAC2E,OAAO,CAACC,UAAR,CAAmB,KAAKzI,SAAxB,CAAL,EAAyC;AACvC,aAAOjB,IAAI,CAAC0D,IAAL,CAAU,KAAKzC,SAAf,EAA0B,KAAKsB,OAAL,CAAajB,kBAAvC,CAAP;AACD;;AAED,WAAOmI,OAAP;AACD;;AAED7G,EAAAA,YAAY,GAAG;AACb,UAAM+G,SAAS,GAAG,OAAO,KAAKpH,OAAL,CAAaqH,QAApB,KAAiC,UAAnD;;AACA,QAAID,SAAJ,EAAe;AACb,WAAK1C,WAAL,GAAoBT,IAAD,IAAU;AAC3B,YAAIqD,GAAG,GAAG,EAAV;AACA,YAAI/E,IAAI,GAAG,KAAKvC,OAAL,CAAajB,kBAAxB;;AACA,YAAIkF,IAAI,CAACE,gBAAT,EAA2B;AACzB;AACA,WAAC;AAAEmD,YAAAA,GAAF;AAAO/E,YAAAA;AAAP,cAAgB9E,IAAI,CAACiE,KAAL,CAAWuC,IAAI,CAACE,gBAAhB,CAAjB;;AACA,cAAI,KAAKnE,OAAL,CAAazB,cAAb,KAAgC,IAApC,EAA0C;AACxC+I,YAAAA,GAAG,GAAG,EAAN;AACD;AACF;;AACD,eAAO,KAAKtH,OAAL,CAAaqH,QAAb,CAAsBxH,IAAtB,CAA2B,IAA3B,EAAiC0C,IAAjC,EAAuC+E,GAAvC,EAA4CrD,IAA5C,EAAkD,IAAlD,CAAP;AACD,OAXD;AAYD,KAbD,MAaO;AACL,WAAKS,WAAL,GAAoBT,IAAD,IAAU;AAC3B,cAAM1B,IAAI,GAAGvE,QAAQ,EAArB;;AAEA,YAAIiG,IAAI,IAAI,KAAKjE,OAAL,CAAazB,cAAzB,EAAyC;AACvC,gBAAM4F,gBAAgB,GAAG,OAAOF,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkCA,IAAI,CAACE,gBAAhE;AACA,iBAAQ,GAAE5B,IAAK,GAAE,KAAKmE,aAAL,CAAmBvC,gBAAnB,CAAqC,EAAtD;AACD;;AAED,eAAO5B,IAAP;AACD,OATD;AAUD;AACF;;AAEDlB,EAAAA,eAAe,GAAG;AAChB,QAAI,KAAKrB,OAAL,CAAa9B,SAAb,KAA2B,CAA/B,EAAkC;AAChC,UAAIqJ,WAAW,GAAG,CAAlB;AACA,WAAKjF,EAAL,CAAQ,OAAR,EAAiB,MAAM;AACrBiF,QAAAA,WAAW,IAAI,CAAf;;AACA,YAAIA,WAAW,GAAG,KAAKvH,OAAL,CAAa9B,SAA/B,EAA0C;AACxC,eAAK8D,MAAL,CACE,IAAI1C,eAAJ,CACG,sBAAqB,KAAKU,OAAL,CAAa9B,SAAU,YAD/C,EAEEmB,MAAM,CAACmI,iBAFT,EAGE,GAHF,CADF;AAOD;AACF,OAXD;AAYD;AACF;;AAED/D,EAAAA,SAAS,GAAG;AACV;AACA;AACA;AACA,QAAI,CAAC,KAAK1B,KAAN,IAAe,KAAKzB,SAApB,IAAiC,KAAKgD,KAA1C,EAAiD;AAC/C;AACD;;AAED,SAAKJ,IAAL,CAAU,KAAV;AACD;;AAtjBqC;;AAyjBxCpD,YAAY,CAAC7B,eAAb,GAA+BA,eAA/B;AACAwJ,MAAM,CAACC,OAAP,GAAiB5H,YAAjB","sourcesContent":["/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst os = require('os');\nconst path = require('path');\nconst hexoid = require('hexoid');\nconst once = require('once');\nconst dezalgo = require('dezalgo');\nconst { EventEmitter } = require('events');\nconst { StringDecoder } = require('string_decoder');\nconst qs = require('qs');\n\nconst toHexoId = hexoid(25);\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFileSize: 200 * 1024 * 1024,\n  minFileSize: 1,\n  allowEmptyFiles: true,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  multiples: false,\n  enabledPlugins: ['octetstream', 'querystring', 'multipart', 'json'],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter: function () {\n    return true;\n  },\n};\n\nconst PersistentFile = require('./PersistentFile');\nconst VolatileFile = require('./VolatileFile');\nconst DummyParser = require('./parsers/Dummy');\nconst MultipartParser = require('./parsers/Multipart');\nconst errors = require('./FormidableError.js');\n\nconst { FormidableError } = errors;\n\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nclass IncomingForm extends EventEmitter {\n  constructor(options = {}) {\n    super();\n\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n\n    const dir = path.resolve(\n      this.options.uploadDir || this.options.uploaddir || os.tmpdir(),\n    );\n\n    this.uploaddir = dir;\n    this.uploadDir = dir;\n\n    // initialize with null\n    [\n      'error',\n      'headers',\n      'type',\n      'bytesExpected',\n      'bytesReceived',\n      '_parser',\n    ].forEach((key) => {\n      this[key] = null;\n    });\n\n    this._setUpRename();\n\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._fileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n\n    this.options.enabledPlugins = []\n      .concat(this.options.enabledPlugins)\n      .filter(Boolean);\n\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError(\n        'expect at least 1 enabled builtin plugin, see options.enabledPlugins',\n        errors.missingPlugin,\n      );\n    }\n\n    this.options.enabledPlugins.forEach((pluginName) => {\n      const plgName = pluginName.toLowerCase();\n      // eslint-disable-next-line import/no-dynamic-require, global-require\n      this.use(require(path.join(__dirname, 'plugins', `${plgName}.js`)));\n    });\n\n    this._setUpMaxFields();\n  }\n\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError(\n        '.use: expect `plugin` to be a function',\n        errors.pluginFunction,\n      );\n    }\n    this._plugins.push(plugin.bind(this));\n    return this;\n  }\n\n  parse(req, cb) {\n    this.pause = () => {\n      try {\n        req.pause();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n        return false;\n      }\n      return true;\n    };\n\n    this.resume = () => {\n      try {\n        req.resume();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n        return false;\n      }\n\n      return true;\n    };\n\n    // Setup callback first, so we don't miss anything from data events emitted immediately.\n    if (cb) {\n      const callback = once(dezalgo(cb));\n      const fields = {};\n      let mockFields = '';\n      const files = {};\n\n      this.on('field', (name, value) => {\n        if (\n          this.options.multiples &&\n          (this.type === 'multipart' || this.type === 'urlencoded')\n        ) {\n          const mObj = { [name]: value };\n          mockFields = mockFields\n            ? `${mockFields}&${qs.stringify(mObj)}`\n            : `${qs.stringify(mObj)}`;\n        } else {\n          fields[name] = value;\n        }\n      });\n      this.on('file', (name, file) => {\n        // TODO: too much nesting\n        if (this.options.multiples) {\n          if (hasOwnProp(files, name)) {\n            if (!Array.isArray(files[name])) {\n              files[name] = [files[name]];\n            }\n            files[name].push(file);\n          } else {\n            files[name] = file;\n          }\n        } else {\n          files[name] = file;\n        }\n      });\n      this.on('error', (err) => {\n        callback(err, fields, files);\n      });\n      this.on('end', () => {\n        if (this.options.multiples) {\n          Object.assign(fields, qs.parse(mockFields));\n        }\n        callback(null, fields, files);\n      });\n    }\n\n    // Parse headers and setup the parser, ready to start listening for data.\n    this.writeHeaders(req.headers);\n\n    // Start listening for data.\n    req\n      .on('error', (err) => {\n        this._error(err);\n      })\n      .on('aborted', () => {\n        this.emit('aborted');\n        this._error(new FormidableError('Request aborted', errors.aborted));\n      })\n      .on('data', (buffer) => {\n        try {\n          this.write(buffer);\n        } catch (err) {\n          this._error(err);\n        }\n      })\n      .on('end', () => {\n        if (this.error) {\n          return;\n        }\n        if (this._parser) {\n          this._parser.end();\n        }\n        this._maybeEnd();\n      });\n\n    return this;\n  }\n\n  writeHeaders(headers) {\n    this.headers = headers;\n    this._parseContentLength();\n    this._parseContentType();\n\n    if (!this._parser) {\n      this._error(\n        new FormidableError(\n          'no parser found',\n          errors.noParser,\n          415, // Unsupported Media Type\n        ),\n      );\n      return;\n    }\n\n    this._parser.once('error', (error) => {\n      this._error(error);\n    });\n  }\n\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n    if (!this._parser) {\n      this._error(\n        new FormidableError('uninitialized parser', errors.uninitializedParser),\n      );\n      return null;\n    }\n\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n    this._parser.write(buffer);\n\n    return this.bytesReceived;\n  }\n\n  pause() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  resume() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  onPart(part) {\n    // this method can be overwritten by the user\n    this._handlePart(part);\n  }\n\n  _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(\n        new FormidableError(\n          `the part.originalFilename should be string when it exists`,\n          errors.filenameNotString,\n        ),\n      );\n      return;\n    }\n\n    // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new StringDecoder(\n        part.transferEncoding || this.options.encoding,\n      );\n\n      part.on('data', (buffer) => {\n        this._fieldsSize += buffer.length;\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(\n            new FormidableError(\n              `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,\n              errors.maxFieldsSizeExceeded,\n              413, // Payload Too Large\n            ),\n          );\n          return;\n        }\n        value += decoder.write(buffer);\n      });\n\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n\n    if (!this.options.filter(part)) {\n      return;\n    }\n\n    this._flushing += 1;\n\n    const newFilename = this._getNewName(part);\n    const filepath = this._joinDirectoryName(newFilename);\n    const file = this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype,\n    });\n    file.on('error', (err) => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n\n    file.open();\n    this.openedFiles.push(file);\n\n    part.on('data', (buffer) => {\n      this._fileSize += buffer.length;\n      if (this._fileSize < this.options.minFileSize) {\n        this._error(\n          new FormidableError(\n            `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${this._fileSize} bytes of file data`,\n            errors.smallerThanMinFileSize,\n            400,\n          ),\n        );\n        return;\n      }\n      if (this._fileSize > this.options.maxFileSize) {\n        this._error(\n          new FormidableError(\n            `options.maxFileSize (${this.options.maxFileSize} bytes) exceeded, received ${this._fileSize} bytes of file data`,\n            errors.biggerThanMaxFileSize,\n            413,\n          ),\n        );\n        return;\n      }\n      if (buffer.length === 0) {\n        return;\n      }\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && this._fileSize === 0) {\n        this._error(\n          new FormidableError(\n            `options.allowEmptyFiles is false, file size should be greather than 0`,\n            errors.noEmptyFiles,\n            400,\n          ),\n        );\n        return;\n      }\n\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n        this._maybeEnd();\n      });\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n\n    if (!this.headers['content-type']) {\n      this._error(\n        new FormidableError(\n          'bad content-type header, no content-type',\n          errors.missingContentType,\n          400,\n        ),\n      );\n      return;\n    }\n\n    const results = [];\n    const _dummyParser = new DummyParser(this, this.options);\n\n    // eslint-disable-next-line no-plusplus\n    for (let idx = 0; idx < this._plugins.length; idx++) {\n      const plugin = this._plugins[idx];\n\n      let pluginReturn = null;\n\n      try {\n        pluginReturn = plugin(this, this.options) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(\n          `plugin on index ${idx} failed with: ${err.message}`,\n          errors.pluginFailed,\n          500,\n        );\n        error.idx = idx;\n        throw error;\n      }\n\n      Object.assign(this, pluginReturn);\n\n      // todo: use Set/Map and pass plugin name instead of the `idx` index\n      this.emit('plugin', idx, pluginReturn);\n      results.push(pluginReturn);\n    }\n\n    this.emit('pluginsResults', results);\n\n    // NOTE: probably not needed, because we check options.enabledPlugins in the constructor\n    // if (results.length === 0 /* && results.length !== this._plugins.length */) {\n    //   this._error(\n    //     new Error(\n    //       `bad content-type header, unknown content-type: ${this.headers['content-type']}`,\n    //     ),\n    //   );\n    // }\n  }\n\n  _error(err, eventName = 'error') {\n    // if (!err && this.error) {\n    //   this.emit('error', this.error);\n    //   return;\n    // }\n    if (this.error || this.ended) {\n      return;\n    }\n\n    this.error = err;\n    this.emit(eventName, err);\n\n    if (Array.isArray(this.openedFiles)) {\n      this.openedFiles.forEach((file) => {\n        file.destroy();\n      });\n    }\n  }\n\n  _parseContentLength() {\n    this.bytesReceived = 0;\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n\n  _newParser() {\n    return new MultipartParser(this.options);\n  }\n\n  _newFile({ filepath, originalFilename, mimetype, newFilename }) {\n    return this.options.fileWriteStreamHandler\n      ? new VolatileFile({\n          newFilename,\n          filepath,\n          originalFilename,\n          mimetype,\n          createFileWriteStream: this.options.fileWriteStreamHandler,\n          hashAlgorithm: this.options.hashAlgorithm,\n        })\n      : new PersistentFile({\n          newFilename,\n          filepath,\n          originalFilename,\n          mimetype,\n          hashAlgorithm: this.options.hashAlgorithm,\n        });\n  }\n\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(\n      /\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i,\n    );\n    if (!m) return null;\n\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) =>\n      String.fromCharCode(code),\n    );\n\n    return originalFilename;\n  }\n\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    const extname = path.extname(basename).replace(/(\\.[a-z0-9]+).*/i, '$1');\n\n    if (firstDot === lastDot) {\n      return extname;\n    }\n\n    return basename.slice(firstDot, lastDot) + extname;\n  }\n\n\n\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name);\n\n    // prevent directory traversal attacks\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n\n    return newPath;\n  }\n\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n    if (hasRename) {\n      this._getNewName = (part) => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n        if (part.originalFilename) {\n          // can be null\n          ({ ext, name } = path.parse(part.originalFilename));\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = (part) => {\n        const name = toHexoId();\n\n        if (part && this.options.keepExtensions) {\n          const originalFilename = typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n    \n        return name;\n      }\n    }\n  }\n\n  _setUpMaxFields() {\n    if (this.options.maxFields !== 0) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n        if (fieldsCount > this.options.maxFields) {\n          this._error(\n            new FormidableError(\n              `options.maxFields (${this.options.maxFields}) exceeded`,\n              errors.maxFieldsExceeded,\n              413,\n            ),\n          );\n        }\n      });\n    }\n  }\n\n  _maybeEnd() {\n    // console.log('ended', this.ended);\n    // console.log('_flushing', this._flushing);\n    // console.log('error', this.error);\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n\n    this.emit('end');\n  }\n}\n\nIncomingForm.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\nmodule.exports = IncomingForm;\n"]},"metadata":{},"sourceType":"script"}